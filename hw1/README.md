Доманее задание по лекции 1.
========================

Срок сдачи - 23 марта (до 23:59). Это 3 недели на реализацию.

Там праздники впереди, так что задание большое.

Ваша основная задача на этом курсе - попробовать всё что есть в языке, написав как можно больше разнылчных программ. Чтобы в дальнейшем вы чувствовали себя уверенно в любой ситуации.

Про баги можно прочесть в https://habrahabr.ru/company/mailru/blog/314804/.

Запускать тесты через `go test -v` находясь в папке `bugs`.

bugs
========================

Это неоцениваемое задание. Но оно поможет вам в дальнейшем - тут многие операции или баги с которыми вы можете столкнуться.

Можно не делать, но лучше сделать.

Для разогрева.

tree
========================

Утилита tree.

Выводит дерево каталогов и файлов (если указана опция -f).

Необходимо реализовать функцию `dirTree` внутри `main.go`. Начать можно с https://golang.org/pkg/os/#Open и дальше смотреть какие методы есть у результата.

Код писать в файле main.go

Запускать тесты через `go test -v` находясь в папке c заданием. После запуска вы должны увидеть такой результат:

```
$ go test -v
=== RUN   TestTreeFull
--- PASS: TestTreeFull (0.00s)
=== RUN   TestTreeDir
--- PASS: TestTreeDir (0.00s)
PASS
ok      1/99_hw/tree     0.127s
```

```
go run main.go . -f
├───main.go (1881b)
├───main_test.go (1318b)
└───testdata
	├───project
	│	├───file.txt (19b)
	│	└───gopher.png (70372b)
	├───static
	│	├───css
	│	│	└───body.css (28b)
	│	├───html
	│	│	└───index.html (57b)
	│	└───js
	│		└───site.js (10b)
	├───zline
	│	└───empty.txt (empty)
	└───zzfile.txt (empty)
go run main.go .
└───testdata
	├───project
	├───static
	│	├───css
	│	├───html
	│	└───js
	└───zline
```

Замечания:

* Перенос строки - unix-style ( \n )
* Отступы - символ графики + символ табуляции ( \t )
* Для расчета символа графики в отступах подумайте про последний элемент и префикс предыдущих уровней. Там довольно простое условие. Хорошо помогает проговорить вслух то что вы видите на экране.
* Если вы пользуетесь windows - помните, что там и в linux разделители директорий различаются - используйте лучше `string(os.PathSeparator)`
Рекурсивный алгоритм проще всего. Но можно реализовать и не-рекурсивно
* Вы можете реализовать любые нужные вам функции, вы не ограничены в единственной dirTree. Если вам нужно больше аргументов - создайте другую функцию и вызывайте её рекурсивно. dirTree в этом случае может быть только входной точкой.
* Символы графики лучше копируйте не из текста задания ( который вы читаете сейчас ), а из исходного кода теста ( main_test.go )
* Результаты ( список папок-файлов ) должны быть отсортированы по алфавиту. Т.е. у вас должен быть код который отсортирует уровень. Смотрите для этого пакет sort. Это самая частая причина непрохождения тестов. Тесты запускаются в среде linux. В задании есть докер-файл для тестов ровно в тех же условиях, он сразу выявит все проблемы.
* У вас может быть соблазн использовать глобальные переменные, но вариант с рекурсией проще получается без них, а в не-рекурсивном варианте они вообще не нужны
* сигнатуру функции dirTree ( количество параметров ) менять нельзя, тесты на сервере не пройдут
* если вы столкнётесь с несовместимостью os.File и bytes.Buffer - смотрите видео "Написание тестов для программы уникализации", uniq/wint_tests в коде в уроку, а так же ссылку на хабр ниже

Материалы в помощь:

* https://habrahabr.ru/post/306914/ - пакет io
* https://golang.org/pkg/sort/
* https://golang.org/pkg/io/
* https://golang.org/pkg/io/ioutil/


calc
========================

Необходимо реализовать калькулятор из https://ru.wikibooks.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%A1%D0%B8_%D0%B2_%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D0%B0%D1%85/%D0%9A%D0%B0%D0%BB%D1%8C%D0%BA%D1%83%D0%BB%D1%8F%D1%82%D0%BE%D1%80_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9_%D0%B2_%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B9_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%BE%D0%B9_%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D0%B8 с набором тестов

Там уже готовый код, его толкьо надо переписать на го и написать тесты.

Тесты должны быть как для успешных случаев, так и для неуспешных.

Тесты удобно делать табличными - смотрите примеры в *bugs* - там есть.

В `1/readings_1.md` есть список книг по го, а так же по всем частым и нужным операциям, там вы можеет найти многие примеры кода, которые вам пригодятся.
